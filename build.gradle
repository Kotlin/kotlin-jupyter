import com.beust.klaxon.JsonObject

import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardCopyOption
import java.util.function.Consumer
import java.util.regex.Pattern
import java.util.stream.Collectors

buildscript {
    ext.shadowJarVersion = "5.2.0"
    ext.kotlinVersion = '1.3.70-dev-2104'
    repositories {
        jcenter()
        mavenLocal()
        mavenCentral()
        maven { url 'https://dl.bintray.com/kotlin/kotlin-eap' }
        maven { url 'https://dl.bintray.com/kotlin/kotlin-dev' }
    }
    dependencies {
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion"
        classpath "com.github.jengelman.gradle.plugins:shadow:$shadowJarVersion"
        classpath "com.beust:klaxon:5.2"
    }
}

allprojects {
    apply plugin: 'kotlin'

    repositories {
        jcenter()
        mavenLocal()
        mavenCentral()
//         only when using Kotlin EAP releases ...
        maven { url 'https://dl.bintray.com/kotlin/kotlin-eap' }
        maven { url 'https://dl.bintray.com/kotlin/kotlin-dev' }
        maven { url 'https://kotlin.bintray.com/kotlin-dependencies' }
    }

    dependencies {
        compile "org.jetbrains.kotlin:kotlin-stdlib:$kotlinVersion"

        testCompile 'junit:junit:4.12'
        testCompile "org.jetbrains.kotlin:kotlin-test:$kotlinVersion"
    }

    ext.teamcityArtifactsPath = "teamcity-artifacts"
    ext.tcDir = rootDir.toPath().resolve(ext.teamcityArtifactsPath)
    ext.isTeamcityBuild = ext.tcDir.toFile().exists()

    String defaultVersion = '0.7.15'
    project.ext.isProtectedBranch = isProtectedBranch()
    String buildCounterStr = rootProject.ext.has('build.counter') ?
            rootProject.ext.get('build.counter') : '100500'
    String devAddition = project.ext.isProtectedBranch ? "" : ".dev1"

    String defaultBuildNumber = "$defaultVersion.$buildCounterStr$devAddition"
    String buildNumber = rootProject.ext.has('build.number') ?
            rootProject.ext.get('build.number') : ""
    String buildNumberRegex = "[0-9]+(\\.[0-9]+){3}(\\.dev[0-9]+)?"

    ext.versionFileName = "VERSION"

    if (!Pattern.matches(buildNumberRegex, buildNumber)) {
        def versionFile = ext.tcDir.resolve(ext.versionFileName).toFile()
        if (versionFile.exists()) {
            def lines = versionFile.readLines()
            assert !lines.empty, "There should be at least one line in VERSION file"
            buildNumber = lines.first().trim()
        } else {
            buildNumber = defaultBuildNumber
        }
    }

    project.ext.version = buildNumber

    println("##teamcity[buildNumber '$buildNumber']")

    ext.installPath = project.hasProperty('installPath') ?
            Paths.get(project.getProperty('installPath') as String) :
            Paths.get(System.properties['user.home'].toString(), ".ipython", "kernels", "kotlin")
    ext.installPathStr = installPath.toAbsolutePath().toString()
    ext.debugPort = 1044
    ext.debuggerConfig = "-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=$debugPort"

    ext.configDir = "config"
    //Straight slash is used 'cause it's universal across the platforms, and is used in jar_args config
    ext.configFile = configDir + "/config.json"
    ext.jarArgsFile = configDir + "/jar_args.json"

    ext.jarsPath = "jars"

    ext.kernelFile = "kernel.json"

    ext.condaBuildDir = rootDir.toPath().resolve("conda-pip-build")
    ext.condaMetaDir = "conda"
    ext.condaMetaYaml = "meta.yaml"
    ext.condaKernelDir = "kernel"
    ext.runKernelDir = "run_kotlin_kernel"
    ext.setupPy = "setup.py"
    ext.runKernelPy = "run_kernel.py"
    ext.condaPackageDir = "package"

    ext.distributionDir = rootDir.toPath().resolve("distribution")
}

apply plugin: 'com.github.johnrengelman.shadow'

configurations {
    deploy
}

dependencies {
    compile project(":jupyter-lib")
    compile "org.jetbrains.kotlin:kotlin-reflect:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-scripting-jvm-host-embeddable:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-scripting-common:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-scripting-compiler-embeddable:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-compiler-embeddable:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-script-util:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-main-kts:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-scripting-dependencies:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-scripting-dependencies-maven:$kotlinVersion"

    compile "org.apache.maven:maven-core:3.0.3"
    compile 'org.slf4j:slf4j-api:1.7.25'
    compile 'org.zeromq:jeromq:0.3.5'
    compile 'com.beust:klaxon:5.2'
    runtime 'org.slf4j:slf4j-simple:1.7.25'
    runtime "org.jetbrains.kotlin:jcabi-aether:1.0-dev-3"
    runtime "org.sonatype.aether:aether-api:1.13.1"
    runtime "net.java.dev.jna:jna:5.4.0"

    deploy project(":jupyter-lib")
}

jar.manifest.attributes(
    'Main-class': 'org.jetbrains.kotlin.jupyter.IkotlinKt',
    'Implementation-Version': project.ext.version
)

shadowJar {
    baseName = 'kotlin-jupyter-kernel'
    classifier = ''
    mergeServiceFiles()
}

task cleanInstallDirLocal(){
    doLast {
        installPath.deleteDir()
    }
}

task cleanInstallDirConda(){
    doLast {
        condaBuildDir.deleteDir()
    }
}

boolean isProtectedBranch() {
    def branchProp = 'build_branch'
    def branch = project.ext.has(branchProp) ? project.ext.get(branchProp) as String : null
    println("Current branch: $branch")
    if (branch != null) {
        branch = branch.substring(branch.lastIndexOf('/') + 1)
        return branch == 'master'
    }
    return false
}

void createInstallTasks(Boolean local, java.nio.file.Path specPath, java.nio.file.Path mainInstallPath) {
    def cleanDirTask = local ? cleanInstallDirLocal : cleanInstallDirConda

    createTaskForSpecs(true, local, cleanDirTask, specPath, mainInstallPath)
    createTaskForSpecs(false, local, cleanDirTask, specPath, mainInstallPath)

    def args = new HashMap()
    args.put("type", Copy)
    args.put("dependsOn", cleanDirTask)

    task (args, makeTaskName("copyLibrariesConfig", local)) {
        from configFile
        into mainInstallPath.resolve(configDir)
    }

    task (args, makeTaskName("installLibs", local)) {
        from configurations.deploy
        into mainInstallPath.resolve(jarsPath)
    }

    def installKernelArgs = new HashMap()
    installKernelArgs.put("type", Copy)
    installKernelArgs.put("dependsOn", [cleanDirTask, shadowJar])

    task (installKernelArgs, makeTaskName("installKernel", local)) {
        from shadowJar.outputs
        into mainInstallPath.resolve(jarsPath)
    }
}

void createTaskForSpecs(Boolean debug, Boolean local, Task cleanDir, java.nio.file.Path specPath, java.nio.file.Path mainInstallPath) {
    String taskName = makeTaskName(debug ? "createDebugSpecs" : "createSpecs", local)
    task(taskName) {
        dependsOn cleanDir, shadowJar
        doLast {
            File kernelFile = files { shadowJar }.singleFile

            List<String> libsCp = files { configurations.deploy }.files.collect {
                it.name
            }.asList()

            makeDirs(mainInstallPath.resolve(jarsPath))
            makeDirs(mainInstallPath.resolve(configDir))
            makeDirs(specPath)

            makeJarArgs(mainInstallPath, kernelFile.name, libsCp, configFile, debug ? debuggerConfig : "")
            makeKernelSpec(specPath, local)
        }
    }
}

static String makeTaskName(String prefix, Boolean local) {
    return prefix + (local ? "Local" : "Conda")
}

static void makeDirs(java.nio.file.Path path) {
    File dir = path.toFile()
    if (!dir.exists()) {
        dir.mkdirs();
    }
}

static java.nio.file.Path getSubdir(java.nio.file.Path dir, String... subdir) {
    def newDir = dir
    for (s in subdir) {
        newDir = newDir.resolve(s)
    }
    return newDir
}

void makeKernelSpec(java.nio.file.Path installPath, Boolean localInstall) {
    def argv = localInstall ?
            Arrays.asList("python",
                    installPath.resolve(runKernelPy).toString(),
                    "{connection_file}",
                    installPath.resolve(jarArgsFile).toString(),
                    installPath.toString()) :
            Arrays.asList("python", "-m", "run_kotlin_kernel", "{connection_file}")

    JsonObject json = new JsonObject(new HashMap<String, Object>(){{
        put("display_name", "Kotlin")
        put("language", "kotlin")
        put("argv", argv)
    }})

    def jsonString = json.toJsonString(true, false)

    installPath.resolve(kernelFile).toFile().write(jsonString, 'UTF-8')

    Files.walk(getSubdir(rootDir.toPath(), "kernelspec", "logos")).withCloseable {stream ->
        stream
                .filter { Files.isRegularFile(it) }
                .forEach {
                    Files.copy(it,
                            getSubdir(installPath, it.fileName.toString()),
                            StandardCopyOption.REPLACE_EXISTING)
                }
    }
}

void makeJarArgs(java.nio.file.Path installPath, String kernelJarPath, List<String> classPath, String librariesPath, String debuggerConfig = "") {
    JsonObject json = new JsonObject(new HashMap<String, Object>(){{
        put("mainJar", kernelJarPath)
        put("classPath", classPath)
        put("librariesPath", librariesPath)
        put("debuggerConfig", debuggerConfig)
    }})

    def jsonString = json.toJsonString(true, false)

    installPath.resolve(jarArgsFile).toFile().write(jsonString, 'UTF-8')
}

void replaceVersionTemplate(java.nio.file.Path pathToFile) {
    File f = pathToFile.toFile()
    List<String> lines = f.readLines("UTF-8").stream().map {
        def vv = it.replaceAll("%%VERSION%%", project.ext.version)
        return vv
    }.collect(Collectors.toList())

    new FileWriter(f).withCloseable {fw ->
        lines.forEach {
            fw.write(it + "\n")
        }
    }
}

/****** LOCAL INSTALL ******/
createInstallTasks(true, installPath, installPath)

task copyRunKernelPy(type: Copy, dependsOn: cleanInstallDirLocal) {
    from distributionDir.resolve(runKernelDir).resolve(runKernelPy)
    into installPath
}

task install(dependsOn: [installKernelLocal, installLibsLocal, createSpecsLocal, copyLibrariesConfigLocal, copyRunKernelPy]) {
}

task installDebug(dependsOn: [installKernelLocal, installLibsLocal, createDebugSpecsLocal, copyLibrariesConfigLocal, copyRunKernelPy]) {
}

/****** CONDA INSTALL ******/
task copyCondaFiles(type: Copy, dependsOn: cleanInstallDirConda) {
    from distributionDir
    into condaBuildDir
    exclude '.idea/**'
    doLast {
        replaceVersionTemplate(condaBuildDir.resolve(condaMetaDir).resolve(condaMetaYaml))
        replaceVersionTemplate(condaBuildDir.resolve(setupPy))

        condaBuildDir.resolve(versionFileName).toFile().write(project.ext.version)
    }
}

createInstallTasks(false, condaBuildDir.resolve(condaKernelDir), condaBuildDir.resolve(runKernelDir))

task condaBuild(dependsOn: [copyCondaFiles, installKernelConda, installLibsConda, createSpecsConda, copyLibrariesConfigConda]) {
}

task condaDebugBuild(dependsOn: [copyCondaFiles, installKernelConda, installLibsConda, createDebugSpecsConda, copyLibrariesConfigConda]) {
}

task condaPackage(type: Exec, dependsOn: [cleanInstallDirConda, condaBuild]) {
    doFirst {
        makeDirs(condaBuildDir.resolve(condaPackageDir))
    }
    commandLine 'conda-build', 'conda', '--output-folder', condaPackageDir
    workingDir condaBuildDir
}

class TaskSpec {
    String taskName
}

class UploadTaskSpecs <T extends TaskSpec> {
    T stable
    T dev

    Project project

    String protectedDeployTaskName

    void forEach(Consumer<T> action) {
        [stable, dev].forEach(action)
    }

    void createTasks(Consumer<T> taskCreationAction) {
        forEach(taskCreationAction)

        project.task([dependsOn: project.cleanInstallDirConda], protectedDeployTaskName) {
            if (project.ext.isProtectedBranch) {
                dependsOn(dev.taskName)
            }
        }
    }
}

class CondaTaskSpec extends TaskSpec {
    String username
    String password
}

ext.condaTaskSpecs = new UploadTaskSpecs<CondaTaskSpec>(
        project: project,
        stable: new CondaTaskSpec(
                taskName: "condaUploadStable",
                username: condaUserStable,
                password: condaPasswordStable
        ),
        dev: new CondaTaskSpec(
                taskName: "condaUploadDev",
                username: condaUserDev
        ),
        protectedDeployTaskName: "condaUploadProtected"
)

void doCondaUpload(CondaTaskSpec taskSpec, java.nio.file.Path artifactPath) {
    exec {
        commandLine 'anaconda', 'login',
                '--username', condaTaskSpecs.stable.username,
                '--password', condaTaskSpecs.stable.password
        standardInput new ByteArrayInputStream("yes".bytes)
    }

    Files.walk(artifactPath).withCloseable { stream ->
        def artifact = stream
                .filter { Files.isRegularFile(it) && it.fileName.toString().endsWith(".tar.bz2") }
                .findFirst()
        assert artifact.isPresent(), ".tar.bz2 file should be present in package/noarch dir"

        def artifactFilePath = artifact.get().toAbsolutePath().toString()
        exec {
            commandLine('anaconda', 'upload', '-u', taskSpec.username, artifactFilePath)
        }
    }
}

condaTaskSpecs.createTasks { taskSpec ->
    task(taskSpec.taskName) {
        def artifactsDir = tcDir
        if (!isTeamcityBuild) {
            artifactsDir = getSubdir(condaBuildDir, condaPackageDir, "noarch")
            dependsOn([cleanInstallDirConda, condaPackage])
        }

        doLast {
            doCondaUpload(taskSpec, artifactsDir)
        }
    }
}

/****** PYPI UPLOAD ******/
task pyPiPackage(type: Exec, dependsOn: condaBuild) {
    commandLine 'python', 'setup.py', 'bdist_wheel'
    workingDir condaBuildDir
}

class PyPiTaskSpec extends TaskSpec {
    String repoURL
    String username
    String password
}

def pyPiTaskSpecs = new UploadTaskSpecs<PyPiTaskSpec>(
        project: project,
        stable: new PyPiTaskSpec(
                taskName: "pyPiUploadStable",
                repoURL: "https://upload.pypi.org/legacy/",
                username: stablePyPiUser,
                password: stablePyPiPassword
        ),
        dev: new PyPiTaskSpec(
                taskName: "pyPiUploadDev",
                repoURL: "https://test.pypi.org/legacy/",
                username: devPyPiUser,
                password: devPyPiPassword
        ),
        protectedDeployTaskName: "pyPiUploadProtected"
)

pyPiTaskSpecs.createTasks { taskSpec ->
    task([type: Exec], taskSpec.taskName) {
        if (!isTeamcityBuild) {
            dependsOn([pyPiPackage])
            workingDir(condaBuildDir.resolve("dist"))
        } else {
            workingDir(tcDir)
        }

        commandLine "twine", "upload",
                "-u", taskSpec.username,
                "-p", taskSpec.password,
                "--repository-url", taskSpec.repoURL,
                "*.whl"
    }
}
