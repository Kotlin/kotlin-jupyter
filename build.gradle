import com.beust.klaxon.JsonObject
import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardCopyOption
import java.util.stream.Collectors

buildscript {
    ext.shadowJarVersion = "5.2.0"
    ext.kotlinVersion = '1.3.70-dev-2104'
    repositories {
        jcenter()
        mavenLocal()
        mavenCentral()
        maven { url 'https://dl.bintray.com/kotlin/kotlin-eap' }
        maven { url 'https://dl.bintray.com/kotlin/kotlin-dev' }
    }
    dependencies {
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion"
        classpath "com.github.jengelman.gradle.plugins:shadow:$shadowJarVersion"
        classpath "com.beust:klaxon:5.2"
    }
}

allprojects {
    apply plugin: 'kotlin'

    repositories {
        jcenter()
        mavenLocal()
        mavenCentral()
//         only when using Kotlin EAP releases ...
        maven { url 'https://dl.bintray.com/kotlin/kotlin-eap' }
        maven { url 'https://dl.bintray.com/kotlin/kotlin-dev' }
        maven { url 'https://kotlin.bintray.com/kotlin-dependencies' }
    }

    dependencies {
        compile "org.jetbrains.kotlin:kotlin-stdlib:$kotlinVersion"

        testCompile 'junit:junit:4.12'
        testCompile "org.jetbrains.kotlin:kotlin-test:$kotlinVersion"
    }

    String defaultVersion = '0.7_SNAPSHOT'

    project.ext.version = project.ext.has('build.number') ?
            project.ext.get('build.number') : defaultVersion

    ext.installPath = project.hasProperty('installPath') ?
            Paths.get(project.getProperty('installPath') as String) :
            Paths.get(System.properties['user.home'].toString(), ".ipython", "kernels", "kotlin")
    ext.installPathStr = installPath.toAbsolutePath().toString()
    ext.debugPort = 1044
    ext.debuggerConfig = "-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=$debugPort"

    ext.configDir = "config"
    //Straight slash is used 'cause it's universal across the platforms, and is used in jar_args config
    ext.configFile = configDir + "/config.json"
    ext.jarArgsFile = configDir + "/jar_args.json"

    ext.jarsPath = "jars"

    ext.kernelFile = "kernel.json"

    ext.condaBuildDir = projectDir.toPath().resolve("conda-build")
    ext.condaMetaDir = "conda"
    ext.condaMetaYaml = "meta.yaml"
    ext.condaKernelDir = "kernel"
    ext.runKernelDir = "run_kotlin_kernel"
    ext.setupPy = "setup.py"
    ext.runKernelPy = "run_kernel.py"
    ext.condaPackageDir = "package"

    ext.distributionDir = projectDir.toPath().resolve("distribution")
}

apply plugin: 'com.github.johnrengelman.shadow'

configurations {
    deploy
}

dependencies {
    compile project(":jupyter-lib")
    compile "org.jetbrains.kotlin:kotlin-reflect:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-scripting-jvm-host-embeddable:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-scripting-common:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-scripting-compiler-embeddable:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-compiler-embeddable:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-script-util:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-main-kts:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-scripting-dependencies:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-scripting-dependencies-maven:$kotlinVersion"

    compile "org.apache.maven:maven-core:3.0.3"
    compile 'org.slf4j:slf4j-api:1.7.25'
    compile 'org.zeromq:jeromq:0.3.5'
    compile 'com.beust:klaxon:5.2'
    runtime 'org.slf4j:slf4j-simple:1.7.25'
    runtime "org.jetbrains.kotlin:jcabi-aether:1.0-dev-3"
    runtime "org.sonatype.aether:aether-api:1.13.1"
    runtime "net.java.dev.jna:jna:5.4.0"

    deploy project(":jupyter-lib")
}

jar.manifest.attributes(
    'Main-class': 'org.jetbrains.kotlin.jupyter.IkotlinKt',
    'Implementation-Version': project.ext.version
)

shadowJar {
    baseName = 'kotlin-jupyter-kernel'
    classifier = ''
    mergeServiceFiles()
}

task cleanInstallDirLocal(){
    doLast {
        installPath.deleteDir()
    }
}

task cleanInstallDirConda(){
    doLast {
        condaBuildDir.deleteDir()
    }
}

void createInstallTasks(Boolean local, java.nio.file.Path specPath, java.nio.file.Path mainInstallPath) {
    def cleanDirTask = local ? cleanInstallDirLocal : cleanInstallDirConda

    createTaskForSpecs(true, local, cleanDirTask, specPath, mainInstallPath)
    createTaskForSpecs(false, local, cleanDirTask, specPath, mainInstallPath)

    def args = new HashMap()
    args.put("type", Copy)
    args.put("dependsOn", cleanDirTask)

    task (args, makeTaskName("copyLibrariesConfig", local)) {
        from configFile
        into mainInstallPath.resolve(configDir)
    }

    task (args, makeTaskName("installLibs", local)) {
        from configurations.deploy
        into mainInstallPath.resolve(jarsPath)
    }

    def installKernelArgs = new HashMap()
    installKernelArgs.put("type", Copy)
    installKernelArgs.put("dependsOn", [cleanDirTask, shadowJar])

    task (installKernelArgs, makeTaskName("installKernel", local)) {
        from shadowJar.outputs
        into mainInstallPath.resolve(jarsPath)
    }
}

void createTaskForSpecs(Boolean debug, Boolean local, Task cleanDir, java.nio.file.Path specPath, java.nio.file.Path mainInstallPath) {
    String taskName = makeTaskName(debug ? "createDebugSpecs" : "createSpecs", local)
    task(taskName) {
        dependsOn cleanDir
        doLast {
            File kernelFile = files { shadowJar }.singleFile

            List<String> libsCp = files { configurations.deploy }.files.collect {
                it.name
            }.asList()

            makeDirs(mainInstallPath.resolve(jarsPath))
            makeDirs(mainInstallPath.resolve(configDir))
            makeDirs(specPath)

            makeJarArgs(mainInstallPath, kernelFile.name, libsCp, configFile, debug ? debuggerConfig : "")
            makeKernelSpec(specPath, local)
        }
    }
}

static String makeTaskName(String prefix, Boolean local) {
    return prefix + (local ? "Local" : "Conda")
}

static void makeDirs(java.nio.file.Path path) {
    File dir = path.toFile()
    if (!dir.exists()) {
        dir.mkdirs();
    }
}

static java.nio.file.Path getSubdir(java.nio.file.Path dir, String... subdir) {
    def newDir = dir
    for (s in subdir) {
        newDir = newDir.resolve(s)
    }
    return newDir
}

void makeKernelSpec(java.nio.file.Path installPath, Boolean localInstall) {
    def argv = localInstall ?
            Arrays.asList("python",
                    installPath.resolve(runKernelPy).toString(),
                    "{connection_file}",
                    installPath.resolve(jarArgsFile).toString(),
                    installPath.toString()) :
            Arrays.asList("python", "-m", "run_kotlin_kernel", "{connection_file}")

    JsonObject json = new JsonObject(new HashMap<String, Object>(){{
        put("display_name", "Kotlin")
        put("language", "kotlin")
        put("argv", argv)
    }})

    def jsonString = json.toJsonString(true, false)

    installPath.resolve(kernelFile).toFile().write(jsonString, 'UTF-8')

    Files.walk(getSubdir(projectDir.toPath(), "kernelspec", "logos")).withCloseable {stream ->
        stream
                .filter { Files.isRegularFile(it) }
                .forEach {
                    Files.copy(it,
                            getSubdir(installPath, it.fileName.toString()),
                            StandardCopyOption.REPLACE_EXISTING)
                }
    }
}

void makeJarArgs(java.nio.file.Path installPath, String kernelJarPath, List<String> classPath, String librariesPath, String debuggerConfig = "") {
    JsonObject json = new JsonObject(new HashMap<String, Object>(){{
        put("mainJar", kernelJarPath)
        put("classPath", classPath)
        put("librariesPath", librariesPath)
        put("debuggerConfig", debuggerConfig)
    }})

    def jsonString = json.toJsonString(true, false)

    installPath.resolve(jarArgsFile).toFile().write(jsonString, 'UTF-8')
}

void replaceVersionTemplate(java.nio.file.Path pathToFile) {
    File f = pathToFile.toFile()
    List<String> lines = f.readLines("UTF-8").stream().map {
        def vv = it.replaceAll("%%VERSION%%", project.ext.version)
        return vv
    }.collect(Collectors.toList())

    new FileWriter(f).withCloseable {fw ->
        lines.forEach {
            fw.write(it + "\n")
        }
    }
}


/****** LOCAL INSTALL ******/
createInstallTasks(true, installPath, installPath)

task copyRunKernelPy(type: Copy, dependsOn: cleanInstallDirLocal) {
    from distributionDir.resolve(runKernelDir).resolve(runKernelPy)
    into installPath
}

task install(dependsOn: [installKernelLocal, installLibsLocal, createSpecsLocal, copyLibrariesConfigLocal, copyRunKernelPy]) {
}

task installDebug(dependsOn: [installKernelLocal, installLibsLocal, createDebugSpecsLocal, copyLibrariesConfigLocal, copyRunKernelPy]) {
}

/****** CONDA INSTALL ******/
task copyCondaFiles(type: Copy, dependsOn: cleanInstallDirConda) {
    from distributionDir
    into condaBuildDir
    exclude '.idea/**'
    doLast {
        replaceVersionTemplate(condaBuildDir.resolve(condaMetaDir).resolve(condaMetaYaml))
        replaceVersionTemplate(condaBuildDir.resolve(setupPy))
    }
}

createInstallTasks(false, condaBuildDir.resolve(condaKernelDir), condaBuildDir.resolve(runKernelDir))

task condaBuild(dependsOn: [copyCondaFiles, installKernelConda, installLibsConda, createSpecsConda, copyLibrariesConfigConda]) {
}

task condaDebugBuild(dependsOn: [copyCondaFiles, installKernelConda, installLibsConda, createDebugSpecsConda, copyLibrariesConfigConda]) {
}

task condaPackage(type: Exec, dependsOn: [cleanInstallDirConda, condaBuild]) {
    doFirst {
        makeDirs(condaBuildDir.resolve(condaPackageDir))
    }
    commandLine 'conda-build', 'conda', '--output-folder', condaPackageDir
    workingDir condaBuildDir
}

task condaUpload(type: Exec, dependsOn: [cleanInstallDirConda, condaPackage, test]) {
    doFirst {
        Files.walk(getSubdir(condaBuildDir, condaPackageDir, "noarch")).withCloseable { stream ->
            def artifact = stream
                    .filter { Files.isRegularFile(it) && it.fileName.toString().endsWith(".tar.bz2") }
                    .findFirst()
            assert artifact.isPresent(), ".tar.bz2 file should be present in package/noarch dir"

            println(artifact.get())
            def artifactPath = artifact.get().toAbsolutePath().toString()
            commandLine('anaconda', 'upload', '-c', 'jetbrains', artifactPath)
        }
    }
}
