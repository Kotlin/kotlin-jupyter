import com.beust.klaxon.JsonObject

import java.nio.file.Paths
import java.util.function.Consumer
import java.util.regex.Pattern

buildscript {
    ext.shadowJarVersion = "5.2.0"
    ext.kotlinVersion = '1.3.70-dev-2104'
    repositories {
        jcenter()
        mavenLocal()
        mavenCentral()
        maven { url 'https://dl.bintray.com/kotlin/kotlin-eap' }
        maven { url 'https://dl.bintray.com/kotlin/kotlin-dev' }
    }
    dependencies {
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion"
        classpath "com.github.jengelman.gradle.plugins:shadow:$shadowJarVersion"
        classpath "com.beust:klaxon:5.2"
    }
}

allprojects {
    apply plugin: 'kotlin'

    repositories {
        jcenter()
        mavenLocal()
        mavenCentral()
//         only when using Kotlin EAP releases ...
        maven { url 'https://dl.bintray.com/kotlin/kotlin-eap' }
        maven { url 'https://dl.bintray.com/kotlin/kotlin-dev' }
        maven { url 'https://kotlin.bintray.com/kotlin-dependencies' }
    }

    dependencies {
        compile "org.jetbrains.kotlin:kotlin-stdlib:$kotlinVersion"

        testCompile 'junit:junit:4.12'
        testCompile "org.jetbrains.kotlin:kotlin-test:$kotlinVersion"
    }

    ext.artifactsPathStr = project.findProperty('artifactsPath') ?: 'artifacts'
    ext.artifactsDir = rootDir.toPath().resolve(artifactsPathStr)

    String defaultVersion = '0.7.15'
    ext.packageName = 'kotlin-jupyter-kernel'
    project.ext.isProtectedBranch = isProtectedBranch()
    String buildCounterStr = rootProject.findProperty('build.counter') ?: '100500'
    String devAddition = project.ext.isProtectedBranch ? '' : '.dev1'

    String defaultBuildNumber = "$defaultVersion.$buildCounterStr$devAddition"
    String buildNumber = rootProject.findProperty('build.number') ?: ''
    String buildNumberRegex = "[0-9]+(\\.[0-9]+){3}(\\.dev[0-9]+)?"

    ext.versionFileName = "VERSION"

    if (!Pattern.matches(buildNumberRegex, buildNumber)) {
        def versionFile = ext.artifactsDir.resolve(ext.versionFileName).toFile()
        if (versionFile.exists()) {
            def lines = versionFile.readLines()
            assert !lines.empty, "There should be at least one line in VERSION file"
            buildNumber = lines.first().trim()
        } else {
            buildNumber = defaultBuildNumber
        }
    }

    ext.buildVersion = buildNumber

    println("##teamcity[buildNumber '$buildVersion']")

    ext.installPath = project.hasProperty('installPath') ?
            Paths.get(project.getProperty('installPath') as String) :
            Paths.get(System.properties['user.home'].toString(), ".ipython", "kernels", "kotlin")
    ext.installPathStr = installPath.toAbsolutePath().toString()

    ext.debugPort = 1044
    ext.debuggerConfig = "-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=$debugPort".toString()

    ext.jarsPath = "jars"
    ext.kernelFile = "kernel.json"
    ext.configDir = "config"
    // Straight slash is used 'cause it's universal across the platforms, and is used in jar_args config
    ext.configFile = configDir + "/config.json"
    ext.jarArgsFile = configDir + "/jar_args.json"

    ext.distributionDir = rootDir.toPath().resolve("distribution")
    ext.distribBuildDir = rootDir.toPath().resolve("distrib-build")
    ext.distribKernelDir = "kernel"
    ext.runKernelDir = "run_kotlin_kernel"
    ext.setupPy = "setup.py"
    ext.runKernelPy = "run_kernel.py"

    ext.condaMetaDir = "conda"
    ext.condaMetaYaml = "meta.yaml"
    ext.condaPackageDir = "conda-package"
    ext.condaPackageName = packageName
    ext.condaPackageFileName = "$condaPackageName-${buildVersion}-py_0.tar.bz2".toString()

    ext.pyPiPackageDir = "pip-package"
    ext.pyPiPackageName = packageName.replaceAll("-", "_")
    ext.pyPiPackageFileName = "$pyPiPackageName-${buildVersion}-py3-none-any.whl".toString()

    ext.copyLibrariesConfigTaskPrefix = "copyLibrariesConfig"
    ext.installLibsTaskPrefix = "installLibs"
    ext.installKernelTaskPrefix = "installKernel"
    ext.cleanInstallDirTaskPrefix = "cleanInstallDir"
}

apply plugin: 'com.github.johnrengelman.shadow'

configurations {
    deploy
}

dependencies {
    compile project(":jupyter-lib")
    compile "org.jetbrains.kotlin:kotlin-reflect:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-scripting-jvm-host-embeddable:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-scripting-common:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-scripting-compiler-embeddable:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-compiler-embeddable:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-script-util:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-main-kts:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-scripting-dependencies:$kotlinVersion"
    compile "org.jetbrains.kotlin:kotlin-scripting-dependencies-maven:$kotlinVersion"

    compile "org.apache.maven:maven-core:3.0.3"
    compile 'org.slf4j:slf4j-api:1.7.25'
    compile 'org.zeromq:jeromq:0.3.5'
    compile 'com.beust:klaxon:5.2'
    runtime 'org.slf4j:slf4j-simple:1.7.25'
    runtime "org.jetbrains.kotlin:jcabi-aether:1.0-dev-3"
    runtime "org.sonatype.aether:aether-api:1.13.1"
    runtime "net.java.dev.jna:jna:5.4.0"

    deploy project(":jupyter-lib")
}

jar.manifest.attributes(
    'Main-class': 'org.jetbrains.kotlin.jupyter.IkotlinKt',
    'Implementation-Version': buildVersion
)

shadowJar {
    archiveBaseName.set(packageName)
    archiveClassifier.set('')
    mergeServiceFiles()
}

boolean isProtectedBranch() {
    def branchProp = 'build.branch'
    def branch = project.findProperty(branchProp) as String
    println("Current branch: $branch")
    if (branch != null) {
        branch = branch.substring(branch.lastIndexOf('/') + 1)
        return branch == 'master'
    }
    return false
}

static String makeTaskName(String prefix, Boolean local) {
    return prefix + (local ? "Local" : "Distrib")
}

static void makeDirs(java.nio.file.Path path) {
    File dir = path.toFile()
    if (!dir.exists()) {
        dir.mkdirs()
    }
}

static java.nio.file.Path getSubDir(java.nio.file.Path dir, String... subDir) {
    def newDir = dir
    for (s in subDir) {
        newDir = newDir.resolve(s)
    }
    return newDir
}

static void writeJson(Map<String, Object> json, java.nio.file.Path path) {
    def jsonString = new JsonObject(json).toJsonString(true, false)
    path.toFile().write(jsonString, 'UTF-8')
}

void createCleanTasks() {
    [true, false].forEach { local ->
        def dir = local ? installPath : distribBuildDir
        task(makeTaskName(cleanInstallDirTaskPrefix, local)) {
            doLast {
                dir.deleteDir()
            }
        }
    }
}
createCleanTasks()

void createInstallTasks(Boolean local, java.nio.file.Path specPath, java.nio.file.Path mainInstallPath) {
    def cleanDirTask = getTasks().getByName(makeTaskName(cleanInstallDirTaskPrefix, local))
    def args = [type: Copy, dependsOn: cleanDirTask]

    task (args, makeTaskName(copyLibrariesConfigTaskPrefix, local)) {
        from configFile
        into mainInstallPath.resolve(configDir)
    }

    task (args, makeTaskName(installLibsTaskPrefix, local)) {
        from configurations.deploy
        into mainInstallPath.resolve(jarsPath)
    }

    task ([type: Copy, dependsOn: [cleanDirTask, shadowJar]], makeTaskName(installKernelTaskPrefix, local)) {
        from shadowJar.outputs
        into mainInstallPath.resolve(jarsPath)
    }

    [true, false].forEach { debug ->
        def specTaskName = createTaskForSpecs(debug, local, cleanDirTask, specPath, mainInstallPath)
        createMainInstallTask(debug, local, specTaskName)
    }
}

String createTaskForSpecs(Boolean debug, Boolean local, Task cleanDir, java.nio.file.Path specPath, java.nio.file.Path mainInstallPath) {
    String taskName = makeTaskName(debug ? "createDebugSpecs" : "createSpecs", local)
    task(taskName) {
        dependsOn cleanDir, shadowJar
        doLast {
            File kernelFile = files { shadowJar }.singleFile

            List<String> libsCp = files { configurations.deploy }.files.collect {
                it.name
            }.asList()

            makeDirs(mainInstallPath.resolve(jarsPath))
            makeDirs(mainInstallPath.resolve(configDir))
            makeDirs(specPath)

            makeJarArgs(mainInstallPath, kernelFile.name, libsCp, configFile, debug ? debuggerConfig : "")
            makeKernelSpec(specPath, local)
        }
    }
    return taskName
}

void createMainInstallTask(Boolean debug, Boolean local, String specsTaskName) {
    def taskNamePrefix = local ? "install" : "prepare"
    def taskNameMiddle = debug ? "Debug": ""
    def taskNameSuffix = local ? "" : "Package"
    def taskName = "$taskNamePrefix$taskNameMiddle$taskNameSuffix"

    def dependencies = [
            local ? copyRunKernelPy : prepareDistributionDir,
            makeTaskName(installKernelTaskPrefix, local),
            makeTaskName(installLibsTaskPrefix, local),
            specsTaskName,
            makeTaskName(copyLibrariesConfigTaskPrefix, local)
    ]

    task(taskName) {
        dependsOn(dependencies)
    }
}

void makeKernelSpec(java.nio.file.Path installPath, Boolean localInstall) {
    def argv = localInstall ?
            Arrays.asList("python",
                    installPath.resolve(runKernelPy).toString(),
                    "{connection_file}",
                    installPath.resolve(jarArgsFile).toString(),
                    installPath.toString()) :
            Arrays.asList("python", "-m", "run_kotlin_kernel", "{connection_file}")

    writeJson([
            "display_name": "Kotlin",
            "language": "kotlin",
            "argv": argv,
    ], installPath.resolve(kernelFile))

    project.copy {
        from getSubDir(rootDir.toPath(), "kernelspec", "logos")
        into installPath
    }
}

void makeJarArgs(java.nio.file.Path installPath, String kernelJarPath, List<String> classPath, String librariesPath, String debuggerConfig = "") {
    writeJson([
            "mainJar": kernelJarPath,
            "classPath": classPath,
            "librariesPath": librariesPath,
            "debuggerConfig": debuggerConfig,
    ], installPath.resolve(project.jarArgsFile))
}

/****** Local install ******/
task copyRunKernelPy(type: Copy, dependsOn: cleanInstallDirLocal) {
    from distributionDir.resolve(runKernelDir).resolve(runKernelPy)
    into installPath
}

createInstallTasks(true, installPath, installPath)

/****** Prepare distribution ******/
task copyDistribFiles(type: Copy, dependsOn: cleanInstallDirDistrib) {
    from distributionDir
    into distribBuildDir
    exclude '.idea/**'
}

task prepareDistributionDir(dependsOn: [cleanInstallDirDistrib, copyDistribFiles]) {
    doLast {
        def versionFilePath = distribBuildDir.resolve(versionFileName)
        versionFilePath.toFile().write(buildVersion as String)
        project.copy {
            from versionFilePath
            into artifactsDir
        }
    }
}

createInstallTasks(false, distribBuildDir.resolve(distribKernelDir), distribBuildDir.resolve(runKernelDir))

/****** Conda upload ******/
task condaPackage(type: Exec, dependsOn: [cleanInstallDirDistrib, preparePackage]) {
    commandLine 'conda-build', 'conda', '--output-folder', condaPackageDir
    workingDir distribBuildDir
    doLast {
        copy {
            from distribBuildDir.resolve(condaPackageDir).resolve("noarch").resolve(condaPackageFileName)
            into artifactsDir
        }
    }
}

class TaskSpec {
    String taskName
}

class UploadTaskSpecs <T extends TaskSpec> {
    T stable
    T dev

    Project project
    String repoName

    UploadTaskSpecs(Project project, String repoName, T stable, T dev) {
        this.project = project
        this.repoName = repoName
        this.stable = stable
        this.dev = dev

        this.stable.taskName = taskName("Stable")
        this.dev.taskName = taskName("Dev")
    }

    String taskName(String type) {
        return repoName + "Upload" + type
    }

    void createTasks(Consumer<T> taskCreationAction) {
        if (project.isProtectedBranch) {
            taskCreationAction.accept(stable)
        }
        taskCreationAction.accept(dev)

        project.task([dependsOn: project.cleanInstallDirDistrib], taskName("Protected")) {
            if (project.isProtectedBranch) {
                dependsOn(dev.taskName)
            }
        }
    }
}

class CondaCredentials {
    String username
    String password
}

class CondaTaskSpec extends TaskSpec {
    String username
    CondaCredentials credentials
}

ext.condaCredentials = new CondaCredentials(
        username: condaUserStable,
        password: condaPasswordStable
)

ext.condaTaskSpecs = new UploadTaskSpecs<CondaTaskSpec>(
        project, "conda",
        new CondaTaskSpec(
                username: condaUserStable,
                credentials: ext.condaCredentials
        ),
        new CondaTaskSpec(
                username: condaUserDev,
                credentials: ext.condaCredentials
        )
)

condaTaskSpecs.createTasks { TaskSpec taskSpec ->
    task(taskSpec.taskName) {
        def artifactPath = artifactsDir.resolve(condaPackageFileName)

        if (!artifactPath.toFile().exists()) {
            dependsOn([cleanInstallDirDistrib, condaPackage])
        }

        doLast {
            exec {
                commandLine 'anaconda', 'login',
                        '--username', taskSpec.credentials.username,
                        '--password', taskSpec.credentials.password
                standardInput new ByteArrayInputStream("yes".bytes)
            }

            exec {
                commandLine('anaconda', 'upload', '-u', taskSpec.username, artifactPath.toString())
            }
        }
    }
}

/****** PyPi upload ******/
task pyPiPackage(type: Exec, dependsOn: preparePackage) {
    commandLine 'python', 'setup.py', 'bdist_wheel',
            '--dist-dir', pyPiPackageDir
    workingDir distribBuildDir

    doLast {
        copy {
            from distribBuildDir.resolve(pyPiPackageDir).resolve(pyPiPackageFileName)
            into artifactsDir
        }
    }
}

class PyPiTaskSpec extends TaskSpec {
    String repoURL
    String username
    String password
}

def pyPiTaskSpecs = new UploadTaskSpecs<PyPiTaskSpec>(
        project, "pyPi",
        new PyPiTaskSpec(
                repoURL: "https://upload.pypi.org/legacy/",
                username: stablePyPiUser,
                password: stablePyPiPassword
        ),
        new PyPiTaskSpec(
                repoURL: "https://test.pypi.org/legacy/",
                username: devPyPiUser,
                password: devPyPiPassword
        )
)

pyPiTaskSpecs.createTasks { taskSpec ->
    task([type: Exec], taskSpec.taskName) {
        workingDir(artifactsDir)
        def artifactPath = artifactsDir.resolve(pyPiPackageFileName)

        if (!artifactPath.toFile().exists()) {
            dependsOn([pyPiPackage])
        }

        commandLine "twine", "upload",
                "-u", taskSpec.username,
                "-p", taskSpec.password,
                "--repository-url", taskSpec.repoURL,
                pyPiPackageFileName
    }
}
